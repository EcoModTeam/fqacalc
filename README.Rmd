---
output: github_document
---

<!-- README.md is generated from README.Rmd. Please edit that file -->

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.path = "man/figures/README-",
  out.width = "100%"
)
```

# fqacalc

## A Florisitic Quality Assessment Calculator for R

<!-- badges: start -->
<!-- badges: end -->

This package provides functions for calculating floristic quality metrics based on the 47 regional FQA databases that have been approved for use by the US Army Core of Engineers. 

## Installation

You can install the development version of fqacalc from [GitHub](https://github.com/) with:

``` r
# install.packages("devtools")
devtools::install_github("ifoxfoot/fqacalc")
```

## Example

```{r}
#attach packages required for this tutorial
library(fqacalc)
library(tidyverse)
```

### Package Data

`fqacalc` contains all 47 regional FQA databases that have been either fully approved for use or approved with reservations by the US Army Core of Engineers. By referencing these databases, the package knows what C score to give each plant that the user inputs. Users can see a list of regional databases using the `db_names()` function, and specific FQA databases can be accessed using the `view_db()` function. 

```{r}
#view a list of all 47 available databases
db_names()

#store the Connecticut database as an object
connecticut <- view_db("connecticut_2013")

#view it
head(connecticut)
```

`fqacalc` also comes with a real site assessment from Crooked Island, Michigan, downloaded from [Universal FQA Calculator](https://universalfqa.org/). 

The data is called `crooked_island` and is used to demonstrate how the package works.

```{r}
#take a look at crooked island's plants
head(crooked_island)

#look at the documentation for the data (bottom right pane of R studio)
?crooked_island

#load dataset into local environment
crooked_island <- crooked_island
```

### Functions to see if your observations will be counted

`fqacalc` also contains two functions that help the user understand how the data they input relates to the regional database: `accepted_entries()` and `unassigned_plants()`. `accepted_entries()` is a function that shows which observations in crooked_island were successfully matched to a regional database. To demonstrate how these data viewing functions work I'm going to add a mistake to the `crooked_island` dataset.

```{r}
#introduce a typo
mistake_island <- crooked_island %>% 
  mutate(scientific_name = str_replace(
    scientific_name, "Abies balsamea", "Abies blahblah"))

#store accepted entries
accepted_entries <- accepted_entries(#this is the data
                                     mistake_island, 
                                     #'key' to join the data to regional list
                                     key = "scientific_name", 
                                     #this is the regional list
                                     db = "michigan_2014", 
                                     #include native AND non-native entries
                                     native = F) 

#view accepted entries
head(accepted_entries)
```

Now, when we use `accepted_entries()` to see which species were matched to the regional dataset, we can see that we got a message about the species typo being discarded and we can also see that the accepted entries dataset we created only has 34 entries.

In some cases plants from the user list can be matched to the regional database, but the plant is not associated with any C score! This is usually because not enough is known about that plant. Plants that are matched but have no C score will be excluded from FQI metric calculation. `unassigned_plants()` is a function that shows the user which plants are dropped because they have not been assigned a C score.

```{r}
#To see unassigned_plants in action we're going to montana! 

#first I'll create a df of plants to input
no_c_plants<- data.frame(scientific_name = c("ABRONIA FRAGRANS", 
                                             "ACER GLABRUM", 
                                             "ACER GRANDIDENTATUM", 
                                             "ACER PLATANOIDES"))

#then I'll create a df of unassigned plants
unassigned_plants(no_c_plants, key = "scientific_name", db = "montana_2017")

```

As you can see, two of these species have no C scores.

### Unweighted FQI Metrics

`fqacalc` also contains a variety of functions that calculate Total Species Richness, Native Species Richness, Mean C, Native Mean C, Total FQI, Native FQI, and Adjusted FQI. All of these functions eliminate duplicate species, unmatched species, and species without a C score.

#### Function Arguments

All of the metric functions have the same arguments. (two don't have the native argument)

* **x**: A data frame containing a list of plant species. This data frame *must* have one of the following columns: `scientific_name` or `acronym`. This is something I hope to improve upon.

* **key**: A character string representing the column that will be used to join the input `x` with the regional FQA database. If a value is not specified the default is `"acronym"`. `"scientific_name"` and `"acronym"` are the only acceptable values for key.

* **db**: A character string representing the regional FQA database to use. See `db_names()` for a list of potential values.

* **native**: native Boolean (TRUE or FALSE). If TRUE, calculate metrics using only native species.

#### Functions

```{r}
#total mean c
mean_c(crooked_island, key = "acronym", db = "michigan_2014", native = FALSE)

#native mean C
mean_c(crooked_island, key = "acronym", db = "michigan_2014", native = TRUE)

#total FQI
FQI(crooked_island, key = "acronym", db = "michigan_2014", native = FALSE)

#native FQI
FQI(crooked_island, key = "acronym", db = "michigan_2014", native = TRUE)

#adjusted FQI (always includes both natives and non-natives)
adjusted_FQI(crooked_island, key = "acronym", db = "michigan_2014")
```

And finally, `all_metrics()` prints all the metrics in a data frame format.

```{r}
all_metrics(crooked_island, key = "acronym", db = "michigan_2014")
```

Also, all the functions are documented with help pages.

```{r}
?all_metrics
```

### Cover-Weighted Functions

Cover-Weighted Functions calculate the same metrics but they are weighted by how abundant each species is. Therefore, the input data frame must have a column named `cover` containing cover values. Cover values can be continuous (i.e. percent cover) or classed (i.e. using the braun-blanquet method).

Cover-Weighted Functions come in two flavors: transect functions and quadrat functions. quadrat functions don't allow duplicate species observations but transect functions (which are designed to calculate metrics for a series of quadrats along a transect) do allow species duplication. 

#### Function Arguments

Cover-Weighted Functions have one additional argument: 

* **cover_metric** A character string representing the cover method used. Acceptable cover methods are: `"percent_cover"`, `"carolina_veg_survey"`, `"braun-blanquet"`, `"modified_braun-blanquet"`, `"plots2_braun-blanquet"`, `"doubinmire"`, and `"usfs_ecodata"`. `"percent_cover"` is the default and is recommended because it is the most accurate.

#### Functions

```{r}
#first I'll make a hypothetical plot with cover values
quadrat <- data.frame(acronym  = c("ABEESC", "ABIBAL", "AMMBRE", "ANTELE"),
                      scientific_name = c("Abelmoschus esculentus", 
                      "Abies balsamea", "Ammophila breviligulata", 
                      "Anticlea elegans; zigadenus glaucus"),
                      cover = c(50, 4, 20, 30))

#now I'll make up a transect
transect <- data.frame(acronym  = c("ABEESC", "ABIBAL", "AMMBRE", 
                                    "ANTELE", "ABEESC", "ABIBAL", "AMMBRE"),
                      cover = c(50, 4, 20, 30, 40, 7, 60),
                      quad_id = c(1, 1, 1, 1, 2, 2, 2))

#quadrat mean c (no duplicates allowed!)
quadrat_mean_c(quadrat, key = "acronym", db = "michigan_2014", 
               native = F, cover_metric = "percent_cover")

#transect mean c (duplicates allowed)
transect_mean_c(transect, key = "acronym", db = "michigan_2014", 
               native = F, cover_metric = "percent_cover")

#cover-weighted FQI
cover_FQI(transect, key = "acronym", db = "michigan_2014", native = F, 
          cover_metric = "percent_cover")

#note to self: should we be able to control duplicates in this function??

#cover summary function
all_cover_metrics(transect, key = "acronym", db = "michigan_2014")
```

### Relative Functions

Relative functions calculate relative frequency, coverage, and importance for each category.

Relative functions have some additional arguments which tell the functions what to calculate the relative value of: 

* **species** Optional. A character string equal to the Latin name of a species
to calculate relative value of that species.

* **family** Optional. A character string equal to a taxonomic family to calculate the relative value of that family.

* **physiog** Optional. A character string equal to a physiognomic state (i.e. tree, shrub) to calculate the relative value of that state.

Allthough the arguments are optional, the user has to choose at least one!

```{r}
#say I want to calculate the relative value of a tree

#relative frequency
relative_freq(transect, key = "acronym", db = "michigan_2014", 
              native = FALSE, physiog = "tree")

#relative cover
relative_cover(transect, key = "acronym", db = "michigan_2014",
               native = FALSE, physiog = "tree")

#relative importance
relative_importance(transect, key = "acronym", db = "michigan_2014", 
                    native = FALSE, physiog = "tree")
```
