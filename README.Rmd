---
output: github_document
---

<!-- README.md is generated from README.Rmd. Please edit that file -->

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.path = "man/figures/README-",
  out.width = "100%"
)
```

# fqacalc

## A Florisitic Quality Assessment Calculator for R

<!-- badges: start -->
<!-- badges: end -->

This package provides functions for calculating floristic quality metrics based on 51 regional FQA databases that have been approved for use by the US Army Core of Engineers. 

## Installation

You can install the development version of fqacalc from [GitHub](https://github.com/) with:

``` r
# install.packages("devtools")
devtools::install_github("ifoxfoot/fqacalc")
```

```{r}
#attach packages required for this tutorial
library(fqacalc)
library(tidyverse)
```

## Package Data

`fqacalc` contains all 51 regional FQA databases that have been either fully approved for use or approved with reservations by the US Army Core of Engineers. By referencing these databases, the package knows what C score to give each plant that the user inputs. Users can see a list of regional databases using the `db_names()` function, and specific FQA databases can be accessed using the `view_db()` function. 

```{r}
#view a list of all 51 available databases
head(db_names())

#store the Connecticut database as an object
connecticut <- view_db("connecticut_2013")

#view it
head(connecticut)
```

`fqacalc` also comes with a real site assessment from Crooked Island, Michigan, downloaded from the [Universal FQA Calculator](https://universalfqa.org/). 

The data is called `crooked_island` and is used to demonstrate how the package works.

```{r}
#take a look at crooked island's plants
head(crooked_island)

#look at the documentation for the data (bottom right pane of R studio)
?crooked_island

#load dataset into local environment
crooked_island <- crooked_island
```

## Functions to see if your observations will be counted

`fqacalc` also contains two functions that help the user understand how the data they input relates to the regional database: `accepted_entries()` and `unassigned_plants()`. `accepted_entries()` is a function that shows which observations in the input data frame were successfully matched to a regional database. To demonstrate how these data viewing functions work I'm going to add a mistake to the `crooked_island` data set.

```{r}
#introduce a typo
mistake_island <- crooked_island %>% 
  mutate(scientific_name = str_replace(
    scientific_name, "Abies balsamea", "Abies blahblah"))

#store accepted entries
accepted_entries <- accepted_entries(#this is the data
                                     mistake_island, 
                                     #'key' to join the data to regional list
                                     key = "scientific_name", 
                                     #this is the regional list
                                     db = "michigan_2014", 
                                     #include native AND non-native entries
                                     native = F) 

#view accepted entries
head(accepted_entries)
```

Now, when we use `accepted_entries()` to see which species were matched to the regional dataset, we can see that we got a message about the species typo being discarded and we can also see that the accepted entries dataset we created only has 34 entries.

In some cases plants from the user list can be matched to the regional database, but the plant is not associated with any C score! This is usually because not enough is known about that plant. Plants that are matched but have no C score will be excluded from FQI metric calculation. `unassigned_plants()` is a function that shows the user which plants are dropped because they have not been assigned a C score.

```{r}
#To see unassigned_plants in action we're going to montana! 

#first I'll create a df of plants to input
no_c_plants<- data.frame(scientific_name = c("ABRONIA FRAGRANS", 
                                             "ACER GLABRUM", 
                                             "ACER GRANDIDENTATUM", 
                                             "ACER PLATANOIDES"))

#then I'll create a df of unassigned plants
unassigned_plants(no_c_plants, key = "scientific_name", db = "montana_2017")

```

As you can see, two of these species have no C scores.

## Unweighted FQI Metrics

`fqacalc` also contains a variety of functions that calculate Total Species Richness, Native Species Richness, Mean C, Native Mean C, Total FQI, Native FQI, and Adjusted FQI. All of these functions eliminate duplicate species, unmatched species, and species without a C score.

#### Function Arguments

All of the metric functions have the same arguments. (and two don't have the native argument)

* **x**: A data frame containing a list of plant species. This data frame *must* have one of the following columns: `scientific_name` or `acronym`. This is something I hope to improve upon.

* **key**: A character string representing the column that will be used to join the input `x` with the regional FQA database. If a value is not specified the default is `"scientific_name"`. `"scientific_name"` and `"acronym"` are the only acceptable values for key.

* **db**: A character string representing the regional FQA database to use. See `db_names()` for a list of potential values.

* **native**: native Boolean (TRUE or FALSE). If TRUE, calculate metrics using only native species.

#### Functions

```{r}
#total mean c
mean_c(crooked_island, key = "acronym", db = "michigan_2014", native = FALSE)

#native mean C
mean_c(crooked_island, key = "acronym", db = "michigan_2014", native = TRUE)

#total FQI
FQI(crooked_island, key = "acronym", db = "michigan_2014", native = FALSE)

#native FQI
FQI(crooked_island, key = "acronym", db = "michigan_2014", native = TRUE)

#adjusted FQI (always includes both natives and non-natives)
adjusted_FQI(crooked_island, key = "acronym", db = "michigan_2014")
```

And finally, `all_metrics()` prints all the metrics in a data frame format.

```{r}
all_metrics(crooked_island, key = "acronym", db = "michigan_2014")
```

Also, all the functions are documented with help pages.

```{r}
?all_metrics
```

## Wetness metric

`fqacalc` has one wetness metric, which calculates the mean wetness coefficient per site. Wetness coefficient is based off of the USFWS Wetland Indicator Status. Negative wetness coefficients indicate a stronger affinity for wetlands, while postive wetland coefficients indicate an affinity for uplands. 

```{r}
#mean wetness
mean_w(crooked_island, key = "acronym", db = "michigan_2014")
```


## Cover-Weighted Functions

Cover-Weighted Functions calculate the same metrics but they are weighted by how abundant each species is. Therefore, the input data frame must also have a column named `cover` containing cover values. Cover values can be continuous (i.e. percent cover) or classed (i.e. using the braun-blanquet method).

Cover-Weighted Functions come in two flavors: transect functions and plot functions. Plot functions don't allow duplicate species observations but transect functions (which are designed to calculate metrics for a series of plots along a transect) do allow species duplication. 

#### Function Arguments

Cover-Weighted Functions have one additional argument: 

* **cover_metric** A character string representing the cover method used. Acceptable cover methods are: `"percent_cover"`, `"carolina_veg_survey"`, `"braun-blanquet"`, `"doubinmire"`, and `"usfs_ecodata"`. `"percent_cover"` is the default and is recommended because it is the most accurate.

#### Functions

```{r}
#first I'll make a hypothetical plot with cover values
plot <- data.frame(acronym  = c("ABEESC", "ABIBAL", "AMMBRE", "ANTELE"),
                      scientific_name = c("Abelmoschus esculentus", 
                      "Abies balsamea", "Ammophila breviligulata", 
                      "Anticlea elegans; zigadenus glaucus"),
                      cover = c(50, 4, 20, 30))

#now I'll make up a transect
transect <- data.frame(acronym  = c("ABEESC", "ABIBAL", "AMMBRE", 
                                    "ANTELE", "ABEESC", "ABIBAL", "AMMBRE"),
                      cover = c(50, 4, 20, 30, 40, 7, 60),
                      quad_id = c(1, 1, 1, 1, 2, 2, 2))

#quadrat mean c (no duplicates allowed!)
plot_mean_c(plot, key = "acronym", db = "michigan_2014", 
               native = F, cover_metric = "percent_cover")

#transect mean c (duplicates allowed)
transect_mean_c(transect, key = "acronym", db = "michigan_2014", 
               native = F, cover_metric = "percent_cover")

#cover-weighted FQI
cover_FQI(transect, key = "acronym", db = "michigan_2014", native = F, 
          cover_metric = "percent_cover")

#cover summary function
all_cover_metrics(transect, key = "acronym", db = "michigan_2014")
```

There is also a plot summary function that summarizes plots along a transect. Data is input as a single data frame containing species per plot. This data frame must also have a column representing the plot the species was observed in. This column is then passed to an additional argument

* **plot_id** A character string representing the name of the column in `x` that indicates which plot the species was observed in.

```{r}
#print transect to view structure of data
transect

#plot summary of a transect
plot_summary(x = transect, key = "acronym", db = "michigan_2014", 
             cover_metric = "percent_cover", 
             plot_id = "quad_id")
```


## Relative Functions

Relative functions calculate relative frequency, coverage, and importance for each category.There is also a species summary function that produces a summary of each species' relative metrics in the data frame.

Relative functions have one additional argument which tells the functions what to calculate the relative value of: 

* **col** A character string equal to 'species', 'family', or 'physiog'. 

Relative functions do not have a native argument.

```{r}
#say I want to calculate the relative value of a tree

#relative frequency
relative_freq(transect, key = "acronym", db = "michigan_2014", 
              col = "physiog")

#relative cover
relative_cover(transect, key = "acronym", db = "michigan_2014", 
               col = "family", cover_metric = "percent_cover")

#relative importance
relative_importance(transect, key = "acronym", db = "michigan_2014", 
                    col = "species", cover_metric = "percent_cover")

#species summary
species_summary(transect, key = "acronym", db = "michigan_2014", 
                cover_metric = "percent_cover")
```

## The End
